## Foreword
#### Two Major Concerns
* Programming language is not just a way of getting a computer to perform operations but rather a medium for expressing ideas about methodology. Thus, programs must be **written for people to read** and **only incidentally for machines to execute.**
* The essential foundations of programming is not the syntax of a particular programming-language constructs, nor clever algorithms for computing particular functions efficiently, nor even the mathematical analysis of algorithms and the foundations of computing, but rather **the techniques used to control the intellectual complexity of large software systems.**

#### Skills
* should know what **NOT** to read, **NOT** to understand at **any moment**
* should feel secure about modifying a program, retaining the spirit and style of the original author.
* Control complexity by
  1. building **abstractions that hide details** when appropriate.
  2. establishing **conventional interfaces** that enable us to construct systems by **combining standard, well understood pieces** in a "mix and match" way.
  3. establishing **new languages for describing a design**, each of which emphasizes particular aspects of the design and deemphasizes others.

#### Computer Science
* is **NOT** a science and its significance has little to do with computers.
* Computer revolution is a revolution in the way we think and in the way we express what we think.
* The essence of this change os the emergence of what might best be called **procedural epistemology**, a study of the structure of knowledge from an imperative point of view.
* Mathematics provides a framework for dealing precisely with notions of "what is." Computation provides a framework for dealing with notions of "how to".

##Chapter1: Building Abstractions with Procedures
#### The Elements of programming
1. **primitive expressions**, which represent the simplest entities the language is concerned with
2. **means of combination**, by which compound elements are built from simpler ones
3. **means of abstraction**, by which compound elements can be named and manipulated as units
4. In programming, we usually deal with two kinds of elements: procedures and data. Any powerful programming language should be able to describe primitive data and primitive procedures and should have methods for **combining and abstracting procedures and data.**

#### Procedures and the Processes They Generate
* The ability to visualize the consequences of the actions under consideration is crucial to becoming an expert programmer.
* Only we have learned to visualize the processes generated by various types of procedures can we reliably construct programs that exhibit the desired behavior.

## The key of understanding complicate thing is to ignore details
* Know what not to look at, not to compute, not to think
* The way you would construct a recursive process is by wishful thinking
* Whenever you see yourself writing the same thing down more than once, there must be something wrong. The reason is not because it is wasting time to write some again, it's about idea.
* Abstraction is the key to conquer complexity

## What is data
* Wishful thinking there exists.
* There is no real differences in some sense between procedures and data

## In order to make system robust
* Small changes, small changes on the problems should lead small changes to the solutions
* Instead of solving a particular problem at every level of decomposition of the problem to sub problems
  * We solve the class problems which are neighborhood of the particular problem you're trying to solve
  * The way you do that is by creating a language at that level of detail, in which the solution to those class problems are representable at that language.
  * which is **Embed Language**
* Dispatching on the type of expression, expressions are absolutely essential in building languages
* Data abstraction barriers are powerful tools for controlling complexity. By isolating the underlying representations data objects, we can divide the task of designing a large program into smaller tasks that can be performed separately.
  * But this technique is not very powerful for every "underlying representation" for a data object
* What we todo instead of bringing the rules to the computers by writing a program that is of these rules, in the computers language
  * The way we understanding a rule is from a pattern --> skeleton, if an expression matched a rule it will be transferred to another expression which is instantiated skeleton.
  * We're going to bring the computer to the level of us by running a way by which the computers can understand rules of this sort
  * This is slightly emphasizing
